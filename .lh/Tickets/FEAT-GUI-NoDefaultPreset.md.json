{
    "sourceFile": "Tickets/FEAT-GUI-NoDefaultPreset.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1745511471957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1745511471957,
            "name": "Commit-0",
            "content": "# FEAT-GUI-NoDefaultPreset: Prevent Default Preset Selection in GUI\r\n\r\n## Objective\r\n\r\nModify the Graphical User Interface (GUI) to prevent any preset from being selected by default on application startup. Instead, the GUI should prompt the user to explicitly select a preset from the list before displaying the detailed file preview. This aims to avoid accidental processing with an unintended preset.\r\n\r\n## Problem Description\r\n\r\nCurrently, when the GUI application starts, a preset from the available list is automatically selected. This can lead to user confusion if they are not aware of this behavior and proceed to add assets and process them using a preset they did not intend to use. The preview table also populates automatically based on this default selection, which might not be desired until a conscious preset choice is made.\r\n\r\n## Failed Attempts\r\n\r\n1.  **Attempt 1: Remove Default Selection Logic and Add Placeholder Text:**\r\n    *   **Approach:** Removed code that explicitly set a default selected item in the preset list during initialization. Added a `QLabel` with placeholder text (\"Please select a preset...\") to the preview area and attempted to use `setPlaceholderText` on the `QTableView` (this was incorrect as `QTableView` does not have this method). Managed visibility of the placeholder label and table view.\r\n    *   **Result:** The `setPlaceholderText` call failed with an `AttributeError`. Even after removing the erroneous line and adding a dedicated `QLabel`, a preset was still being selected automatically in the list on startup, and the placeholder was not consistently shown. This suggested that simply populating the `QListWidget` might implicitly trigger a selection.\r\n\r\n2.  **Attempt 2: Explicitly Clear Selection and Refine Visibility Logic:**\r\n    *   **Approach:** Added explicit calls (`setCurrentItem(None)`, `clearSelection()`) after populating the preset list to ensure no item was selected. Refined the visibility logic for the placeholder label and table view in `_clear_editor` and `_load_selected_preset_for_editing`. Added logging to track selection and visibility changes.\r\n    *   **Result:** Despite explicitly clearing the selection, testing indicated that a preset was still being selected on startup, and the placeholder was not consistently displayed. This reinforced the suspicion that the `QListWidget`'s behavior upon population was automatically triggering a selection and the associated signal.\r\n\r\n## Proposed Plan: Implement \"-- Select a Preset --\" Placeholder Item\r\n\r\nThis approach makes the \"no selection\" state an explicit, selectable item in the preset list, giving us more direct control over the initial state and subsequent behavior.\r\n\r\n1.  **Modify `populate_presets` Method:**\r\n    *   Add a `QListWidgetItem` with the text \"-- Select a Preset --\" at the very beginning of the list (index 0) after clearing the list but before adding actual preset items.\r\n    *   Store a special, non-`Path` value (e.g., `None` or a unique string like `\"__PLACEHOLDER__\"`) in this placeholder item's `UserRole` data to distinguish it from real presets.\r\n    *   After adding all real preset items, explicitly set the current item to this placeholder item using `self.editor_preset_list.setCurrentRow(0)`.\r\n\r\n2.  **Modify `_load_selected_preset_for_editing` Method (Slot for `currentItemChanged`):**\r\n    *   At the beginning of the method, check if the `current_item` is the placeholder item by examining its `UserRole` data.\r\n    *   If the placeholder item is selected:\r\n        *   Call `self._clear_editor()` to reset all editor fields.\r\n        *   Call `self.preview_model.clear_data()` to ensure the preview table model is empty.\r\n        *   Explicitly set `self.preview_placeholder_label.setVisible(True)` and `self.preview_table_view.setVisible(False)`.\r\n        *   Return from the method without proceeding to load a preset or call `update_preview`.\r\n    *   If a real preset item is selected, proceed with the existing logic: get the `Path` from the item's data, call `_load_preset_for_editing(preset_path)`, call `self.update_preview()`, set `self.preview_placeholder_label.setVisible(False)` and `self.preview_table_view.setVisible(True)`.\r\n\r\n3.  **Modify `start_processing` Method:**\r\n    *   Before initiating the processing, check if the currently selected item in `editor_preset_list` is the placeholder item.\r\n    *   If the placeholder item is selected, display a warning message to the user (e.g., \"Please select a valid preset before processing.\") using the status bar and return from the method.\r\n    *   If a real preset is selected, proceed with the existing processing logic.\r\n\r\n4.  **Modify `update_preview` Method:**\r\n    *   Add a check at the beginning of the method. Get the `current_item` from `editor_preset_list`. If it is the placeholder item, clear the preview model (`self.preview_model.clear_data()`) and return immediately. This prevents the prediction handler from running when no valid preset is selected.\r\n\r\n## Next Steps\r\n\r\nImplement the proposed plan by modifying the specified methods in `gui/main_window.py`. Test the GUI on startup and when selecting different items in the preset list to ensure the desired behavior is achieved."
        }
    ]
}